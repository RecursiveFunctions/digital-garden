<script type="module">
    // Instead of importing React and ReactDOM, we'll load them from a CDN
    const fetchGraphData = async () => {
        try {
            console.log('Fetching graph data...');
            const response = await fetch('/graph.json');
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const graphData = await response.json();
            console.log('Raw graph data:', graphData);

            // Validate graph data structure
            if (!graphData || !graphData.nodes || !graphData.links) {
                throw new Error('Invalid graph data structure');
            }

            return graphData;
        } catch (error) {
            console.error('Error fetching graph data:', error);
            return null;
        }
    };

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            console.warn('Graph data is null in filterLocalGraphData');
            return { nodes: [], edges: [] };
        }
        
        // Convert object to array of nodes if needed
        const nodesArray = Array.isArray(graphData.nodes) 
            ? graphData.nodes 
            : Object.values(graphData.nodes);
        
        const linksArray = Array.isArray(graphData.links) 
            ? graphData.links 
            : Object.values(graphData.links);

        console.log('Local graph raw data:', { 
            nodesCount: nodesArray.length, 
            linksCount: linksArray.length 
        });

        // Convert graph data to our component's format
        const nodes = nodesArray.map(node => ({
            id: node.url || node.id,
            title: node.title || node.id,
            neighbors: node.neighbors || []
        }));

        const edges = linksArray.map(link => ({
            source: link.source,
            target: link.target
        }));

        console.log('Local graph processed:', { 
            nodes, 
            edges 
        });

        return { nodes, edges };
    }

    function drag(simulation) {
        function dragstarted(event, d) {
            console.log('Drag started:', d);
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            console.log('Dragging:', d);
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            console.log('Drag ended:', d);
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
    }

    function renderGraph(container, nodes, edges) {
        if (!container) {
            console.error('Graph container not found');
            return;
        }

        if (!nodes || nodes.length === 0) {
            console.warn('No nodes to render');
            container.innerHTML = '<div style="padding: 20px; text-align: center;">No graph data available</div>';
            return;
        }

        try {
            console.log('Rendering graph with nodes:', nodes.length, 'and edges:', edges.length);
            
            // Clear previous graph
            container.innerHTML = '';
            
            // Create SVG element with proper sizing
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 500;
            
            console.log('Graph container dimensions:', width, height);
            
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto;");
            
            // Ensure nodes have unique IDs
            const processedNodes = nodes.map((node, index) => ({
                ...node,
                id: node.id || `node-${index}`
            }));

            // Map numeric IDs to actual node objects for links
            const nodeById = new Map(processedNodes.map(node => [node.id, node]));
            
            // Process edges to ensure they reference actual node objects
            const processedEdges = edges.map(edge => {
                const source = typeof edge.source === 'number' ? 
                    processedNodes.find(n => n.id === edge.source) || processedNodes[edge.source] : 
                    nodeById.get(edge.source) || edge.source;
                    
                const target = typeof edge.target === 'number' ? 
                    processedNodes.find(n => n.id === edge.target) || processedNodes[edge.target] : 
                    nodeById.get(edge.target) || edge.target;
                
                return source && target ? { source, target } : null;
            }).filter(Boolean);

            console.log('Processed for graph:', { 
                nodes: processedNodes.length, 
                edges: processedEdges.length 
            });
            
            if (processedEdges.length === 0) {
                console.warn('No valid edges to render');
            }

            // Set up force simulation with optimized parameters
            const simulation = d3.forceSimulation(processedNodes)
                .force("link", d3.forceLink(processedEdges).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX(width / 2).strength(0.1))
                .force("y", d3.forceY(height / 2).strength(0.1))
                .force("collide", d3.forceCollide(15)) // Prevent node overlap
                .alphaDecay(0.05) // Faster convergence
                .alphaMin(0.001);

            // Create a group for graph elements
            const g = svg.append("g");
            
            // Add zoom capability
            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.1, 8])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

            // Create edges
            const link = g.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(processedEdges)
                .join("line")
                .attr("stroke-width", d => Math.sqrt(d.value || 1));

            // Create nodes with custom styling
            const node = g.append("g")
                .selectAll("circle")
                .data(processedNodes)
                .join("circle")
                .attr("r", d => {
                    const numberOfNeighbors = (d.neighbors && d.neighbors.length) || 2;
                    return Math.min(10, Math.max(numberOfNeighbors / 2, 5));
                })
                .attr("fill", "#69b3a2")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .call(drag(simulation))
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("fill", "#ff7675");
                    
                    // Highlight connected links
                    link.style("stroke", l => 
                        l.source.id === d.id || l.target.id === d.id ? "#ff7675" : "#999");
                    
                    // Bring connected nodes to front
                    node.each(function(n) {
                        if (n.id === d.id) {
                            this.parentNode.appendChild(this);
                        }
                    });
                })
                .on("mouseout", function() {
                    d3.select(this).attr("fill", "#69b3a2");
                    link.style("stroke", "#999");
                });

            // Create node labels
            const label = g.append("g")
                .selectAll("text")
                .data(processedNodes)
                .join("text")
                .text(d => d.title || d.id)
                .attr('x', 12)
                .attr('y', 3)
                .style('font-size', '12px')
                .style('pointer-events', 'none') // Make labels not interfere with mouse events
                .style('fill', '#333');

            // Update node and edge positions on each tick  
            simulation.on("tick", () => {
                // Keep nodes within bounds
                processedNodes.forEach(d => {
                    d.x = Math.max(10, Math.min(width - 10, d.x));
                    d.y = Math.max(10, Math.min(height - 10, d.y));
                });
                
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)  
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                label
                    .attr("x", d => d.x + 12)
                    .attr("y", d => d.y + 3);
            });
            
            // Log when the simulation stabilizes
            simulation.on("end", () => {
                console.log("Force simulation has converged");
            });

            // Add the SVG to the container
            container.appendChild(svg.node());

        } catch (error) {
            console.error('Error rendering graph:', error);
            container.innerHTML = '<div style="padding: 20px; color: red;">Error rendering graph: ' + error.message + '</div>';
        }
    }

    async function initializeGraph() {
        try {
            const graphData = await fetchGraphData();
            
            if (!graphData) {
                console.error('Graph data is null or invalid');
                return;
            }
            
            // Render local graph
            const localGraphContainer = document.getElementById('link-graph');
            if (localGraphContainer) {
                const localData = filterLocalGraphData(graphData, 3);
                renderGraph(localGraphContainer, localData.nodes, localData.edges);
            } else {
                console.error('Local graph container not found');
            }

            // Render full graph
            const fullGraphContainer = document.getElementById('full-graph-container');
            if (fullGraphContainer) {
                const fullData = filterLocalGraphData(graphData, 100); // Use a large depth for full graph
                renderGraph(fullGraphContainer, fullData.nodes, fullData.edges);
            } else {
                console.error('Full graph container not found');
            }
        } catch (error) {
            console.error('Error initializing graph:', error);
        }
    }

    // Initialize graph when D3 is loaded
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof d3 !== 'undefined') {
            initializeGraph();
        } else {
            console.error('D3 library not loaded');
        }
    });
</script>

<!-- Load D3.js from CDN -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<div x-data="{ graphData: null, depth: 3, showFullGraph: false }" id="graph-component">
    <div class="graph-title-container">
        <div class="graph-title">Connected Pages</div>
        <div id="graph-controls">
            <div class="depth-control">
                <label for="graph-depth">Depth</label>
                <div class="slider">
                    <input x-model.number="depth" name="graph-depth" list="depthmarkers" type="range" step="1" min="1" max="3" id="graph-depth"/>
                    <datalist id="depthmarkers">
                        <option value="1" label="1"></option>
                        <option value="2" label="2"></option>
                        <option value="3" label="3"></option>
                    </datalist>
                </div>
            </div>
        </div>
    </div>
    <div id="link-graph" class="graph" style="min-height: 320px; min-width: 320px;"></div>
    <div id="full-graph-container" class="graph" x-show="showFullGraph" style="min-height: 500px; min-width: 500px;"></div>
</div>