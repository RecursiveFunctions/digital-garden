<script type="module">
    // Instead of importing React and ReactDOM, we'll load them from a CDN
    const fetchGraphData = async () => {
        try {
            console.log('Fetching graph data...');
            const response = await fetch('/graph.json');
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const graphData = await response.json();
            console.log('Raw graph data:', graphData);

            // Validate graph data structure
            if (!graphData || !graphData.nodes || !graphData.links) {
                throw new Error('Invalid graph data structure');
            }

            return graphData;
        } catch (error) {
            console.error('Error fetching graph data:', error);
            return null;
        }
    };

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            console.warn('Graph data is null in filterLocalGraphData');
            return { nodes: [], edges: [] };
        }
        
        // Convert object to array of nodes if needed
        const nodesArray = Array.isArray(graphData.nodes) 
            ? graphData.nodes 
            : Object.values(graphData.nodes);
        
        const linksArray = Array.isArray(graphData.links) 
            ? graphData.links 
            : Object.values(graphData.links);

        console.log('Local graph raw data:', { 
            nodesCount: nodesArray.length, 
            linksCount: linksArray.length 
        });

        // Create a map from node id to index
        const nodeIdToIndex = {};
        nodesArray.forEach((node, index) => {
            nodeIdToIndex[node.id] = index;
        });

        // Convert graph data to our component's format
        const nodes = nodesArray.map((node, index) => ({
            // Use the original node ID to ensure edges connect properly
            id: node.id,
            originalId: node.id,
            url: node.url,
            title: node.title || node.id,
            neighbors: node.neighbors || [],
            index: index // Store original index
        }));

        console.log('Node ID mapping:', nodeIdToIndex);

        // Map links using the node ID to index mapping
        const edges = linksArray.map(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            
            return {
                source: sourceId,
                target: targetId,
                value: link.value || 1
            };
        });

        console.log('Local graph processed:', { 
            nodes, 
            edges 
        });

        return { nodes, edges };
    }

    function drag(simulation) {
        function dragstarted(event, d) {
            console.log('Drag started:', d);
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            console.log('Dragging:', d);
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            console.log('Drag ended:', d);
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
    }

    function renderGraph(container, nodes, edges) {
        if (!container) {
            console.error('Graph container not found');
            return;
        }

        if (!nodes || nodes.length === 0) {
            console.warn('No nodes to render');
            container.innerHTML = '<div style="padding: 20px; text-align: center;">No graph data available</div>';
            return;
        }

        try {
            console.log('Rendering graph with nodes:', nodes.length, 'and edges:', edges.length);
            
            // Clear previous graph
            container.innerHTML = '';
            
            // Create SVG element with proper sizing
            const width = Math.max(container.clientWidth, 1000) || 1000;
            const height = Math.max(container.clientHeight, 800) || 800;
            
            console.log('Graph container dimensions:', width, height);
            
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto; background: rgba(35, 39, 48, 0.1);");
            
            // Create a lookup map for nodes by ID
            const nodeById = new Map();
            nodes.forEach(node => {
                nodeById.set(node.id, node);
            });
            
            console.log('Node map size:', nodeById.size);
            
            // Process edges to reference node objects directly
            const links = [];
            edges.forEach(edge => {
                const source = nodeById.get(edge.source);
                const target = nodeById.get(edge.target);
                
                if (source && target) {
                    links.push({
                        source,
                        target,
                        value: edge.value || 1
                    });
                } else {
                    console.warn('Could not find nodes for edge:', edge);
                }
            });
            
            console.log('Processed links:', links.length);

            // Create a group for graph elements
            const g = svg.append("g");
            
            // Add zoom capability
            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.1, 8])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

            // Set up force simulation with optimized parameters
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(150)) // Increased distance
                .force("charge", d3.forceManyBody().strength(-800)) // Increased repulsion
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX(width / 2).strength(0.05)) // Decreased strength
                .force("y", d3.forceY(height / 2).strength(0.05)) // Decreased strength
                .force("collide", d3.forceCollide(30)) // Increased collision radius
                .alphaDecay(0.02) // Slower decay for better layout
                .alphaMin(0.001);

            // Create edges
            const link = g.append("g")
                .attr("stroke", "#a8b0bd")
                .attr("stroke-opacity", 0.4)
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke-width", d => Math.sqrt(d.value || 1) * 1.5);

            // Create nodes with custom styling
            const node = g.append("g")
                .selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("r", d => {
                    const numberOfNeighbors = (d.neighbors && d.neighbors.length) || 2;
                    return Math.min(12, Math.max(numberOfNeighbors / 2, 6));
                })
                .attr("fill", "#89cff0") // Light blue nodes
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .call(drag(simulation))
                .on("mouseover", function(event, d) {
                    // Highlight the node
                    d3.select(this)
                      .attr("fill", "#ff7675")
                      .attr("r", function(d) {
                        const currentRadius = +d3.select(this).attr("r");
                        return currentRadius * 1.2;
                      });
                    
                    // Highlight connected links and make them thicker
                    link.style("stroke", l => 
                        l.source.id === d.id || l.target.id === d.id ? "#ff7675" : "#a8b0bd")
                        .style("stroke-opacity", l => 
                        l.source.id === d.id || l.target.id === d.id ? 0.8 : 0.4)
                        .style("stroke-width", l => 
                        l.source.id === d.id || l.target.id === d.id ? 3 : Math.sqrt(l.value || 1) * 1.5);
                    
                    // Highlight connected node labels
                    label.style("font-weight", l => 
                        l.id === d.id || links.some(link => 
                            (link.source.id === d.id && link.target.id === l.id) || 
                            (link.target.id === d.id && link.source.id === l.id)
                        ) ? "bold" : "normal")
                      .style("font-size", l => 
                        l.id === d.id ? "14px" : "12px")
                      .style("fill", l => 
                        l.id === d.id ? "#ff7675" : "#fff");
                    
                    // Bring connected nodes to front
                    node.each(function(n) {
                        if (n.id === d.id) {
                            this.parentNode.appendChild(this);
                        }
                    });

                    // Make tooltip with node info
                    const tooltip = document.createElement('div');
                    tooltip.id = 'graph-tooltip';
                    tooltip.style.position = 'absolute';
                    tooltip.style.left = (event.pageX + 10) + 'px';
                    tooltip.style.top = (event.pageY + 10) + 'px';
                    tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    tooltip.style.color = '#fff';
                    tooltip.style.padding = '5px 10px';
                    tooltip.style.borderRadius = '5px';
                    tooltip.style.fontSize = '12px';
                    tooltip.style.zIndex = '1000';
                    tooltip.innerHTML = `<strong>${d.title}</strong><br/>Connections: ${d.neighbors?.length || 0}`;
                    document.body.appendChild(tooltip);
                })
                .on("mouseout", function() {
                    // Reset node style
                    d3.select(this)
                      .attr("fill", "#89cff0")
                      .attr("r", function(d) {
                        const numberOfNeighbors = (d.neighbors && d.neighbors.length) || 2;
                        return Math.min(12, Math.max(numberOfNeighbors / 2, 6));
                      });
                    
                    // Reset links
                    link.style("stroke", "#a8b0bd")
                        .style("stroke-opacity", 0.4)
                        .style("stroke-width", d => Math.sqrt(d.value || 1) * 1.5);
                    
                    // Reset labels
                    label.style("font-weight", "normal")
                         .style("font-size", "12px")
                         .style("fill", "#fff");
                    
                    // Remove tooltip
                    const tooltip = document.getElementById('graph-tooltip');
                    if (tooltip) {
                        document.body.removeChild(tooltip);
                    }
                });

            // Create node labels
            const label = g.append("g")
                .selectAll("text")
                .data(nodes)
                .join("text")
                .text(d => d.title || d.id)
                .attr('x', 12)
                .attr('y', 3)
                .style('font-size', '12px')
                .style('pointer-events', 'none') // Make labels not interfere with mouse events
                .style('fill', '#fff') // White text for better contrast
                .style('stroke', 'rgba(0,0,0,0.5)') // Text outline for better readability
                .style('stroke-width', '0.5px')
                .style('paint-order', 'stroke');

            // Update node and edge positions on each tick  
            simulation.on("tick", () => {
                // Keep nodes within bounds
                nodes.forEach(d => {
                    d.x = Math.max(10, Math.min(width - 10, d.x));
                    d.y = Math.max(10, Math.min(height - 10, d.y));
                });
                
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)  
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                label
                    .attr("x", d => d.x + 12)
                    .attr("y", d => d.y + 3);
            });
            
            // Log when the simulation stabilizes
            simulation.on("end", () => {
                console.log("Force simulation has converged");
            });

            // Add the SVG to the container
            container.appendChild(svg.node());

            // Update graph container styles
            container.style.backgroundColor = '#232730'; // Dark background color

        } catch (error) {
            console.error('Error rendering graph:', error);
            container.innerHTML = '<div style="padding: 20px; color: red;">Error rendering graph: ' + error.message + '</div>';
        }
    }

    async function initializeGraph() {
        try {
            const graphData = await fetchGraphData();
            
            if (!graphData) {
                console.error('Graph data is null or invalid');
                return;
            }
            
            // Render local graph
            const localGraphContainer = document.getElementById('link-graph');
            if (localGraphContainer) {
                const localData = filterLocalGraphData(graphData, 3);
                renderGraph(localGraphContainer, localData.nodes, localData.edges);
            } else {
                console.error('Local graph container not found');
            }

            // Render full graph
            const fullGraphContainer = document.getElementById('full-graph-container');
            if (fullGraphContainer) {
                const fullData = filterLocalGraphData(graphData, 100); // Use a large depth for full graph
                renderGraph(fullGraphContainer, fullData.nodes, fullData.edges);
            } else {
                console.error('Full graph container not found');
            }
        } catch (error) {
            console.error('Error initializing graph:', error);
        }
    }

    // Initialize graph when D3 is loaded
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof d3 !== 'undefined') {
            initializeGraph();
        } else {
            console.error('D3 library not loaded');
        }
    });
</script>

<!-- Load D3.js from CDN -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<div x-data="{ graphData: null, depth: 3, showFullGraph: false }" id="graph-component">
    <div class="graph-title-container">
        <div class="graph-title">Connected Pages</div>
        <div id="graph-controls">
            <div class="depth-control">
                <label for="graph-depth">Depth</label>
                <div class="slider">
                    <input x-model.number="depth" name="graph-depth" list="depthmarkers" type="range" step="1" min="1" max="3" id="graph-depth"/>
                    <datalist id="depthmarkers">
                        <option value="1" label="1"></option>
                        <option value="2" label="2"></option>
                        <option value="3" label="3"></option>
                    </datalist>
                </div>
            </div>
        </div>
    </div>
    <div id="link-graph" class="graph" style="min-height: 600px; min-width: 100%; height: 600px;"></div>
    <div id="full-graph-container" class="graph" x-show="showFullGraph" style="min-height: 800px; min-width: 100%; height: 800px;"></div>
</div>