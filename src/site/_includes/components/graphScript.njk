<script type="module">
    // Instead of importing React and ReactDOM, we'll load them from a CDN
    const fetchGraphData = async () => {
        try {
            console.log('Fetching graph data...');
            const response = await fetch('/graph.json');
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const graphData = await response.json();
            console.log('Raw graph data:', graphData);

            // Validate graph data structure
            if (!graphData || !graphData.nodes || !graphData.links) {
                throw new Error('Invalid graph data structure');
            }

            return graphData;
        } catch (error) {
            console.error('Error fetching graph data:', error);
            return null;
        }
    };

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            console.warn('Graph data is null in filterLocalGraphData');
            return { nodes: [], edges: [] };
        }
        
        // Convert object to array of nodes if needed
        const nodesArray = Array.isArray(graphData.nodes) 
            ? graphData.nodes 
            : Object.values(graphData.nodes);
        
        const linksArray = Array.isArray(graphData.links) 
            ? graphData.links 
            : Object.values(graphData.links);

        console.log('Local graph raw data:', { 
            nodesCount: nodesArray.length, 
            linksCount: linksArray.length 
        });

        // Create a map from node id to index
        const nodeIdToIndex = {};
        nodesArray.forEach((node, index) => {
            nodeIdToIndex[node.id] = index;
        });

        // Convert graph data to our component's format
        const nodes = nodesArray.map((node, index) => ({
            // Use the original node ID to ensure edges connect properly
            id: node.id,
            originalId: node.id,
            url: node.url,
            title: node.title || node.id,
            neighbors: node.neighbors || [],
            index: index // Store original index
        }));

        console.log('Node ID mapping:', nodeIdToIndex);

        // Map links using the node ID to index mapping
        const edges = linksArray.map(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            
            return {
                source: sourceId,
                target: targetId,
                value: link.value || 1
            };
        });

        console.log('Local graph processed:', { 
            nodes, 
            edges 
        });

        return { nodes, edges };
    }

    function drag(simulation) {
        function dragstarted(event, d) {
            console.log('Drag started:', d);
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            console.log('Dragging:', d);
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            console.log('Drag ended:', d);
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
    }

    function renderGraph(container, nodes, edges) {
        if (!container) {
            console.error('Graph container not found');
            return;
        }

        if (!nodes || nodes.length === 0) {
            console.warn('No nodes to render');
            container.innerHTML = '<div style="padding: 20px; text-align: center; color: #cdd6f4;">No graph data available</div>';
            return;
        }

        try {
            console.log('Rendering graph with nodes:', nodes.length, 'and edges:', edges.length);
            
            // Clear previous graph
            container.innerHTML = '';
            
            // Create SVG element with proper sizing
            const width = Math.max(container.clientWidth, 1000) || 1000;
            const height = Math.max(container.clientHeight, 800) || 800;
            
            console.log('Graph container dimensions:', width, height);
            
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto;");
            
            // Create a lookup map for nodes by ID
            const nodeById = new Map();
            nodes.forEach(node => {
                nodeById.set(node.id, node);
            });
            
            console.log('Node map size:', nodeById.size);
            
            // Process edges to reference node objects directly
            const links = [];
            edges.forEach(edge => {
                const source = nodeById.get(edge.source);
                const target = nodeById.get(edge.target);
                
                if (source && target) {
                    links.push({
                        source,
                        target,
                        value: edge.value || 1
                    });
                } else {
                    console.warn('Could not find nodes for edge:', edge);
                }
            });
            
            console.log('Processed links:', links.length);

            // Create a group for graph elements
            const g = svg.append("g");
            
            // Add zoom capability
            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.1, 8])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

            // Catppuccin Mocha Theme Colors
            const colors = {
                background: '#1e1e2e',
                text: '#cdd6f4',
                subtext: '#bac2de',
                surface: '#313244',
                overlay: '#45475a',
                base: '#24273a',
                mantle: '#181825',
                crust: '#11111b',
                rosewater: '#f5e0dc',
                flamingo: '#f2cdcd',
                pink: '#f5c2e7',
                mauve: '#cba6f7',
                red: '#f38ba8',
                maroon: '#eba0ac',
                peach: '#fab387',
                yellow: '#f9e2af',
                green: '#a6e3a1',
                teal: '#94e2d5',
                sky: '#89dceb',
                sapphire: '#74c7ec',
                blue: '#89b4fa',
                lavender: '#b4befe'
            };

            // Group color mapping based on node group
            const groupColors = {
                'none': colors.blue,
                'Daily Notes': colors.green,
                'Programming': colors.mauve,
                'Projects': colors.peach,
                'Personal': colors.pink,
                'Reference': colors.yellow
            };

            // Set up force simulation with optimized parameters
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(50))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX(width / 2).strength(0.1))
                .force("y", d3.forceY(height / 2).strength(0.1))
                .force("collide", d3.forceCollide(15))
                .alphaDecay(0.05)
                .alphaMin(0.001);

            // Create edges
            const link = g.append("g")
                .attr("stroke", colors.overlay)
                .attr("stroke-opacity", 0.5)
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke-width", d => Math.sqrt(d.value || 1) * 0.8);

            // Create nodes with custom styling
            const node = g.append("g")
                .selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("r", d => {
                    const numberOfNeighbors = (d.neighbors && d.neighbors.length) || 2;
                    return Math.min(10, Math.max(numberOfNeighbors / 2, 5));
                })
                .attr("fill", d => groupColors[d.group] || colors.blue)
                .attr("stroke", colors.text)
                .attr("stroke-width", 1)
                .attr("data-node-id", d => d.id)
                .attr("class", "graph-node")
                .call(drag(simulation))
                .on("mouseover", function(event, d) {
                    // Highlight the node
                    d3.select(this)
                      .attr("fill", colors.lavender)
                      .attr("r", function(d) {
                        const currentRadius = +d3.select(this).attr("r");
                        return currentRadius * 1.2;
                      });
                    
                    // Highlight connected links and make them thicker
                    link.style("stroke", l => 
                        l.source.id === d.id || l.target.id === d.id ? colors.lavender : colors.overlay)
                        .style("stroke-opacity", l => 
                        l.source.id === d.id || l.target.id === d.id ? 0.8 : 0.5)
                        .style("stroke-width", l => 
                        l.source.id === d.id || l.target.id === d.id ? 2 : Math.sqrt(l.value || 1) * 0.8);
                    
                    // Highlight connected node labels
                    label.style("font-weight", l => 
                        l.id === d.id || links.some(link => 
                            (link.source.id === d.id && link.target.id === l.id) || 
                            (link.target.id === d.id && link.source.id === l.id)
                        ) ? "bold" : "normal")
                      .style("font-size", l => 
                        l.id === d.id ? "14px" : "12px")
                      .style("fill", l => 
                        l.id === d.id ? colors.lavender : colors.text);
                    
                    // Bring connected nodes to front
                    node.each(function(n) {
                        if (n.id === d.id) {
                            this.parentNode.appendChild(this);
                        }
                    });

                    // Make tooltip with node info
                    const tooltip = document.createElement('div');
                    tooltip.id = 'graph-tooltip';
                    tooltip.style.position = 'absolute';
                    tooltip.style.left = (event.pageX + 10) + 'px';
                    tooltip.style.top = (event.pageY + 10) + 'px';
                    tooltip.style.backgroundColor = colors.surface;
                    tooltip.style.color = colors.text;
                    tooltip.style.padding = '8px 12px';
                    tooltip.style.borderRadius = '8px';
                    tooltip.style.fontSize = '14px';
                    tooltip.style.zIndex = '1000';
                    tooltip.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
                    tooltip.style.border = `1px solid ${colors.overlay}`;
                    tooltip.innerHTML = `<strong>${d.title}</strong><br/><span style="color:${colors.subtext}">Connections: ${d.neighbors?.length || 0}</span>`;
                    document.body.appendChild(tooltip);
                })
                .on("mouseout", function(d) {
                    // Reset node style
                    d3.select(this)
                      .attr("fill", d => groupColors[d.group] || colors.blue)
                      .attr("r", function(d) {
                        const numberOfNeighbors = (d.neighbors && d.neighbors.length) || 2;
                        return Math.min(10, Math.max(numberOfNeighbors / 2, 5));
                      });
                    
                    // Reset links
                    link.style("stroke", colors.overlay)
                        .style("stroke-opacity", 0.5)
                        .style("stroke-width", d => Math.sqrt(d.value || 1) * 0.8);
                    
                    // Reset labels
                    label.style("font-weight", "normal")
                         .style("font-size", "12px")
                         .style("fill", colors.text);
                    
                    // Remove tooltip
                    const tooltip = document.getElementById('graph-tooltip');
                    if (tooltip) {
                        document.body.removeChild(tooltip);
                    }
                })
                .on("click", function(event, d) {
                    // Remove previous focus
                    d3.selectAll(".graph-node").classed("focused-node", false);
                    // Add focus to clicked node
                    d3.select(this).classed("focused-node", true);
                    
                    // Navigate to the note when clicked
                    if (d.url) {
                        window.location.href = d.url;
                    }
                    
                    // Set this node as the focal node and update the graph
                    const depthControl = document.getElementById('graph-depth');
                    if (depthControl) {
                        const depth = parseInt(depthControl.value);
                        updateGraphWithDepth(d.id, depth);
                    }
                });

            // Create node labels
            const label = g.append("g")
                .selectAll("text")
                .data(nodes)
                .join("text")
                .text(d => d.title || d.id)
                .attr('x', 12)
                .attr('y', 3)
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('fill', colors.text)
                .style('font-family', 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif');

            // Update node and edge positions on each tick  
            simulation.on("tick", () => {
                // Keep nodes within bounds
                nodes.forEach(d => {
                    d.x = Math.max(10, Math.min(width - 10, d.x));
                    d.y = Math.max(10, Math.min(height - 10, d.y));
                });
                
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)  
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                label
                    .attr("x", d => d.x + 12)
                    .attr("y", d => d.y + 3);
            });
            
            // Log when the simulation stabilizes
            simulation.on("end", () => {
                console.log("Force simulation has converged");
            });

            // Add the SVG to the container
            container.appendChild(svg.node());

            // Update graph container styles
            container.style.backgroundColor = colors.background;
            
            // Store graph data in the container for depth filtering
            container.dataset.graphData = JSON.stringify({
                originalNodes: nodes,
                originalLinks: links
            });
            
            // Return the components for external access
            return {
                svg, g, node, link, label, simulation
            };

        } catch (error) {
            console.error('Error rendering graph:', error);
            container.innerHTML = `<div style="padding: 20px; color: ${colors.red}; background-color: ${colors.crust}; border-radius: 8px; margin: 10px;">Error rendering graph: ${error.message}</div>`;
        }
    }

    // Update the graph based on the current depth setting
    function updateGraphWithDepth(centralNodeId, depth) {
        const localGraphContainer = document.getElementById('link-graph');
        const fullGraphContainer = document.getElementById('full-graph-container');
        
        if (!localGraphContainer && !fullGraphContainer) {
            console.error('No graph containers found');
            return;
        }
        
        // Handle each container that's present
        [localGraphContainer, fullGraphContainer].forEach(container => {
            if (!container) return;
            
            try {
                // Get the stored original graph data
                const storedData = container.dataset.graphData;
                if (!storedData) {
                    console.warn('No stored graph data found in container');
                    return;
                }
                
                const { originalNodes, originalLinks } = JSON.parse(storedData);
                
                // Filter nodes and links based on the depth
                const { nodes: filteredNodes, links: filteredLinks } = filterByDepth(
                    originalNodes, 
                    originalLinks, 
                    centralNodeId, 
                    depth
                );
                
                // Clear the existing graph
                container.innerHTML = '';
                
                // Re-render the graph with the filtered data
                renderGraph(container, filteredNodes, filteredLinks);
                
                console.log(`Filtered graph to depth ${depth}: ${filteredNodes.length} nodes, ${filteredLinks.length} links`);
            } catch (error) {
                console.error('Error updating graph with depth:', error);
            }
        });
    }

    async function initializeGraph() {
        try {
            const graphData = await fetchGraphData();
            
            if (!graphData) {
                console.error('Graph data is null or invalid');
                return;
            }
            
            // Convert graph data nodes to array if it's an object
            const nodesArray = Array.isArray(graphData.nodes) 
                ? graphData.nodes 
                : Object.values(graphData.nodes);
            
            // Convert graph data links to array if it's an object
            const linksArray = Array.isArray(graphData.links) 
                ? graphData.links 
                : Object.values(graphData.links);
            
            // Get current page URL to use as central node
            const currentPath = window.location.pathname;
            console.log(`Current page path: ${currentPath}`);
            
            // Find the node that matches the current path
            const centralNode = nodesArray.find(n => n.url === currentPath);
            
            if (!centralNode) {
                console.warn('Could not find node for current page:', currentPath);
                return;
            }
            
            // Render local graph
            const localGraphContainer = document.getElementById('link-graph');
            if (localGraphContainer) {
                // Filter graph data with the current page as the central node
                const localData = filterLocalGraphData(graphData, 3);
                renderGraph(localGraphContainer, localData.nodes, localData.edges);
                
                // Set up depth control event listener
                const depthControl = document.getElementById('graph-depth');
                if (depthControl) {
                    depthControl.addEventListener('input', function() {
                        const depth = parseInt(this.value);
                        console.log(`Depth changed to: ${depth}`);
                        
                        // Always use the current page node as the central node
                        if (centralNode) {
                            updateGraphWithDepth(centralNode.id, depth);
                        } else {
                            console.warn('Could not find node for current page');
                        }
                    });
                }
            } else {
                console.error('Local graph container not found');
            }

            // Render full graph
            const fullGraphContainer = document.getElementById('full-graph-container');
            if (fullGraphContainer) {
                const fullData = filterLocalGraphData(graphData, 100); // Use a large depth for full graph
                renderGraph(fullGraphContainer, fullData.nodes, fullData.edges);
            } else {
                console.error('Full graph container not found');
            }
        } catch (error) {
            console.error('Error initializing graph:', error);
        }
    }

    // Initialize graph when D3 is loaded
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof d3 !== 'undefined') {
            initializeGraph();
        } else {
            console.error('D3 library not loaded');
        }
    });

    // Create graph data filter based on depth
    function filterByDepth(nodes, links, currentNodeId, maxDepth) {
        // If no current node is selected, return all nodes
        if (!currentNodeId) return { nodes, links };

        // Map node IDs to their objects for faster lookup
        const nodeMap = new Map();
        nodes.forEach(node => nodeMap.set(node.id, node));
        
        // Create a map of node ID to distance from selected node
        const distanceMap = new Map();
        
        // BFS to find all nodes within maxDepth
        const queue = [{id: currentNodeId, distance: 0}];
        distanceMap.set(currentNodeId, 0);
        
        while (queue.length > 0) {
            const { id, distance } = queue.shift();
            const node = nodeMap.get(id);
            
            if (!node) continue;
            
            // If we've reached max depth, don't explore further
            if (distance >= maxDepth) continue;
            
            // Get neighbors from links
            const neighbors = links.reduce((acc, link) => {
                if (link.source.id === id && !distanceMap.has(link.target.id)) {
                    acc.push({id: link.target.id, distance: distance + 1});
                    distanceMap.set(link.target.id, distance + 1);
                } else if (link.target.id === id && !distanceMap.has(link.source.id)) {
                    acc.push({id: link.source.id, distance: distance + 1});
                    distanceMap.set(link.source.id, distance + 1);
                }
                return acc;
            }, []);
            
            queue.push(...neighbors);
        }
        
        // Filter nodes and links by depth
        const filteredNodes = nodes.filter(node => distanceMap.has(node.id) && distanceMap.get(node.id) <= maxDepth);
        const filteredLinks = links.filter(link => 
            distanceMap.has(link.source.id) && 
            distanceMap.has(link.target.id) && 
            distanceMap.get(link.source.id) <= maxDepth && 
            distanceMap.get(link.target.id) <= maxDepth
        );
        
        return { nodes: filteredNodes, links: filteredLinks };
    }

    // Add event listener for depth slider
    document.addEventListener('DOMContentLoaded', function() {
        const depthSlider = document.getElementById('graph-depth');
        if (depthSlider) {
            depthSlider.addEventListener('input', function(e) {
                const depth = parseInt(e.target.value);
                // Get the currently focused node or use the first node
                const focusedNode = document.querySelector('.focused-node');
                const nodeId = focusedNode ? focusedNode.dataset.nodeId : nodes[0]?.id;
                if (nodeId) {
                    updateGraphWithDepth(nodeId, depth);
                }
            });
        }
    });

    // Add CSS for focused node
    const style = document.createElement('style');
    style.textContent = `
        .graph-node {
            transition: all 0.3s ease;
        }
        .focused-node {
            stroke: ${colors.lavender};
            stroke-width: 3px;
            r: 12px;
        }
    `;
    document.head.appendChild(style);
</script>

<!-- Load D3.js from CDN -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<div x-data="{ graphData: null, depth: 3, showFullGraph: false }" id="graph-component">
    <div class="graph-title-container">
        <div class="graph-title">Connected Pages</div>
        <div id="graph-controls">
            <div class="depth-control">
                <label for="graph-depth">Depth</label>
                <div class="slider">
                    <input x-model.number="depth" name="graph-depth" list="depthmarkers" type="range" step="1" min="1" max="3" id="graph-depth"/>
                    <datalist id="depthmarkers">
                        <option value="1" label="1"></option>
                        <option value="2" label="2"></option>
                        <option value="3" label="3"></option>
                    </datalist>
                </div>
            </div>
        </div>
    </div>
    <div id="link-graph" class="graph" style="min-height: 600px; min-width: 100%; height: 600px; border-radius: 12px; overflow: hidden; border: 1px solid #313244;"></div>
    <div id="full-graph-container" class="graph" x-show="showFullGraph" style="min-height: 800px; min-width: 100%; height: 800px; border-radius: 12px; overflow: hidden; border: 1px solid #313244;"></div>
</div>

<!-- Depth control styling -->
<style>
    #graph-component {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    .graph-title-container {
        background-color: #1e1e2e;
        color: #cdd6f4;
        border-radius: 12px 12px 0 0;
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 1px solid #313244;
        border-bottom: none;
    }
    .graph-title {
        font-weight: 600;
        font-size: 18px;
    }
    #graph-controls {
        display: flex;
        align-items: center;
        gap: 12px;
    }
    .depth-control {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .depth-control label {
        font-size: 14px;
        color: #bac2de;
    }
    .slider {
        position: relative;
        width: 150px;
    }
    input[type="range"] {
        width: 100%;
        height: 5px;
        -webkit-appearance: none;
        appearance: none;
        background: #313244;
        outline: none;
        border-radius: 5px;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #89b4fa;
        cursor: pointer;
        border: 2px solid #cdd6f4;
        transition: background 0.2s;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
        background: #b4befe;
    }
    input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #89b4fa;
        cursor: pointer;
        border: 2px solid #cdd6f4;
        transition: background 0.2s;
    }
    input[type="range"]::-moz-range-thumb:hover {
        background: #b4befe;
    }
    datalist {
        display: flex;
        justify-content: space-between;
        color: #bac2de;
        font-size: 12px;
        margin-top: 4px;
    }
</style>